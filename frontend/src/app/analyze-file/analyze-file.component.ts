import { Component, ViewChild, ElementRef, AfterViewInit, OnInit } from '@angular/core';
import * as L from 'leaflet';

interface Vendor {
  name: string;
  logoUrl: string;
  hasDetected: boolean;
  lastDetectionUpdate: string;
}

interface Dll {
  name: string;
  function: string;
}

interface MicrosoftResult {
  descr: string;
  url: string;
}

interface Event {
  mitreAttackTechnique: string;
  runningTime: string;
  source: string;
  eventId: number;
  eventDescription: string;
}

interface Ip {
  ip: string;
  country: string;
  lat: number;
  long: number;
  company: string;
  onTor: boolean;
  torServerName: string;
}

@Component({
  selector: 'app-analyze-file',
  templateUrl: './analyze-file.component.html',
  styleUrls: ['./analyze-file.component.css']
})
export class AnalyzeFileComponent implements OnInit {
  @ViewChild('fileInput') fileInput!: ElementRef;

  private map: L.Map | undefined;

  vendors: Vendor[] = [];
  dlls: Dll[] = [];
  microsoftResults: MicrosoftResult[]= [];
  events: Event[] = [];
  ips: Ip[] = [];
  ipsStandard: Ip[] = [];
  ipsTor: Ip[] = [];

  showAnalysis: boolean = false;

  // Stats
  dllsFrequency: Map<string, number> = new Map<string, number>();
  eventsFrequency: Map<number, number> = new Map<number, number>();

  constructor() { }
  ngOnInit(): void { }

  analyseXmlFile(fileInput: any): void {
    this.showAnalysis = false;

    const files: FileList = fileInput.files;
    if(files && files.length > 0) {
      const selectedFile: File = files[0];

      const fileReader: FileReader = new FileReader();
      fileReader.onload = (e: any) => {
        const fileContents: string = e.target.result;
        const parser: DOMParser = new DOMParser();
        const xmlDoc: Document = parser.parseFromString(fileContents, 'text/xml');

        this.getVendors(xmlDoc);
        this.getDlls(xmlDoc);
        this.getMicrosoftResults(xmlDoc);
        this.getEvents(xmlDoc);
        this.getIps(xmlDoc);

        this.initMap();

        this.showAnalysis = true;
      };
      fileReader.readAsText(selectedFile);
    }
  }

  private getVendors(xmlDoc: Document): void {
      const vendorElements: NodeListOf<Element> = xmlDoc.querySelectorAll('Vendor');
      for (let i = 0; i < vendorElements.length; i++) {
        const vendorElement: Element = vendorElements[i];
        const vendorName: string = vendorElement.querySelector('Name')?.textContent || '';
        const vendorLogoUrl: string = vendorElement.querySelector('Logo')?.textContent || '';
        const vendorHasDetectedText: string = vendorElement.querySelector('Detected')?.textContent || '';
        const vendorLastDetectionUpdate: string = vendorElement.querySelector('Update')?.textContent || '';

        const vendorHasDetected: boolean = vendorHasDetectedText === "Yes";

        const lastUpdateDetectionTreated: string = this.stringToFrDate(vendorLastDetectionUpdate);

        const vendor: Vendor = {
          name: vendorName,
          logoUrl: vendorLogoUrl,
          hasDetected: vendorHasDetected,
          lastDetectionUpdate: lastUpdateDetectionTreated
        };
        this.vendors.push(vendor);
      } 
  }

  private stringToFrDate(string: string): string {

    const wrongFormat: string[] = string.split('');
    const year: string = wrongFormat[0] + wrongFormat[1] + wrongFormat[2] + wrongFormat[3];
    const month: string = wrongFormat[4] + wrongFormat[5];
    const day: string = wrongFormat[6] + wrongFormat[7];
    
    return day + "." + month + "." + year;
}

  private getDlls(xmlDoc: Document): void {
    const dllElements: NodeListOf<Element> = xmlDoc.querySelectorAll('DLL');
    for (let i = 0; i < dllElements.length; i ++) {
      const dllElement: Element = dllElements[i];
      
      // Removing the debug DLLs of VStudio
      const dllName: string = dllElement.getAttribute('name') || '';
      if (this.filterUselessDlls(dllName)) {
        continue;
      }

      // Stats
      if (this.dllsFrequency.has(dllName)) {
        const frequency: number = this.dllsFrequency.get(dllName)! + 1;
        this.dllsFrequency.set(dllName, frequency);
      }else {
        this.dllsFrequency.set(dllName, 1);
      }
      
      const dllFunctions: NodeListOf<Element> = dllElement.querySelectorAll('Function');
      for (let j = 0; j < dllFunctions.length; j++) {
        const dllFunction: string = dllFunctions[j].textContent || '';
        const dll: Dll = {
          name: dllName,
          function: dllFunction
        }
        this.dlls.push(dll);
      }
    }
  }

  /**
   * Removing the debug DLLs of VStudio
   * @param dllName 
   * @returns 
   */
  private filterUselessDlls(dllName: string): boolean {
    return dllName === "MSVCP140D.dll" || 
            dllName === "ucrtbased.dll" ||
            dllName === "VCRUNTIME140_1D.dll" ||
            dllName === "VCRUNTIME140D.dll";
  }

  private getMicrosoftResults(xmlDoc: Document): void {
    const microsoftElements: NodeListOf<Element> = xmlDoc.querySelectorAll('ResolvedFunction');
    for (let i = 0; i < microsoftElements.length; i++){
      const microsoftElement: Element = microsoftElements[i];
      const microsoftDescr: string = microsoftElement.querySelector('Title')?.textContent || '';
      const microsoftUrl: string = microsoftElement.querySelector('Link')?.textContent || '';

      if (microsoftDescr !== "" && microsoftUrl !== "") {
        const microsoftResult: MicrosoftResult = {
        descr: microsoftDescr,
        url: microsoftUrl
      }
      this.microsoftResults.push(microsoftResult);
      }
    }
  }

  isLink(link: string): boolean {
    return link !== "N/A";
  }

private getEvents(xmlDoc: Document): void {
  const eventElements: NodeListOf<Element> = xmlDoc.querySelectorAll('Event');

  // We only want to display the 50 first events
  let maxEvents: number = Math.min(eventElements.length, 50);

  for (let i = 0; i < maxEvents; i++) {
    const eventElement: Element = eventElements[i];

    // Removing inoffenseive events
    const eventId: number = Number(eventElement.querySelector('EventID')?.textContent);
    if (eventId < 0) {
      maxEvents++;
      continue;
    }

    // Stats
    if (this.eventsFrequency.has(eventId)) {
      const frequency: number = this.eventsFrequency.get(eventId)! + 1;
      this.eventsFrequency.set(eventId, frequency);
    }else {
      this.eventsFrequency.set(eventId, 1);
    }

    const eventMitreAttackTechnique: string = eventElement.querySelector('MitreAttackTechnique')?.textContent || '';
    const eventTime: string = eventElement.querySelector('Time')?.textContent || '';
    const eventSource: string = eventElement.querySelector('Source')?.textContentÂ || '';
    const eventDescription: string = eventElement.querySelector('EventData')?.textContent || '';

    const eventDescriptionReduced: string = eventDescription.substring(0, 200);

    const eventTimeTreated: string = this.stringToFrDateAndTime(eventTime);

    const event: Event = {
      mitreAttackTechnique: eventMitreAttackTechnique,
      runningTime: eventTimeTreated,
      source: eventSource,
      eventId: eventId,
      eventDescription: eventDescriptionReduced
    }
    this.events.push(event);
  }
}

private stringToFrDateAndTime(string: string): string {
  const dateAndTime: string [] = string.split(' ');
  const time: string = dateAndTime[1];
  const date: string = dateAndTime[0];
  const wrongFormat: string[] = date.split('-');
  const year: string = wrongFormat[0];
  const month: string = wrongFormat[1];
  const day: string = wrongFormat[2];
  return day + "." + month + "." + year + " " + time;
}

private getIps(xmlDoc: Document): void {
  const ipElements: NodeListOf<Element> = xmlDoc.querySelectorAll('IpAddrInfo');
  for (let i = 0; i < ipElements.length; i++) {
    const ipElement: Element = ipElements[i];
    const ip: string = ipElement.querySelector('IP')?.textContent || '';
    const country: string = ipElement.querySelector('CountryName')?.textContent || '';
    const lat: number = Number(ipElement.querySelector('Latitude')?.textContent);
    const long: number = Number(ipElement.querySelector('Longitude')?.textContent);
    const company: string = ipElement.querySelector('Company')?.textContent || '';
    const onTorText: string = ipElement.querySelector('TorServer')?.textContent || '';
    const torServerName: string = ipElement.querySelector('TorServerName')?.textContent || '';

    const onTor: boolean = onTorText === "Yes";

    const ipInfo: Ip = {
      ip: ip,
      country: country,
      lat: lat,
      long: long,
      company: company,
      onTor: onTor,
      torServerName: torServerName
    }

    this.ips.push(ipInfo);
  }
}

private initMap(): void {
  this.map = L.map('map').setView([31.794525, -7.0849336], 1); 

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
    maxZoom: 18,
    minZoom: 1
  }).addTo(this.map);

  this.addMarkers();
}

private addMarkers(): void {

  this.getIpCoordinates();

    const customIconBasic = L.icon({
      iconUrl: 'assets/leaflet/marker-icon.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41]
    });

    const customIconTor = L.icon({
      iconUrl: 'assets/leaflet/marker-icon-red.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41]
    });

    this.ipsStandard.forEach(ipElement => {
      const marker = L.marker([ipElement.lat, ipElement.long], { icon : customIconBasic}).addTo(this.map!);
      marker.bindPopup(`<b>IP: </b>${ipElement.ip}<br><b>Country: </b>${ipElement.country}<br>`);
    })

    this.ipsTor.forEach(ipElement => {
      const marker = L.marker([ipElement.lat, ipElement.long], { icon: customIconTor}).addTo(this.map!);
      marker.bindPopup(`<b>IP: </b>${ipElement.ip}<br><b>Country: </b>${ipElement.country}<br>`);
    })
}

private getIpCoordinates(): void {
  const ipsWithTorFirst: Ip[] = this.sortIpsWithTorFirst(this.ips);
  ipsWithTorFirst.forEach(ipElement => {
    if(!Number.isNaN(ipElement.lat) && !Number.isNaN(ipElement.long)) {
      const ipToAdd: Ip = {
        ip: ipElement.ip,
        country: ipElement.country,
        lat: ipElement.lat,
        long: ipElement.long,
        company: '',
        onTor: ipElement.onTor,
        torServerName: ''
      };
      if (!this.ipsIncludeCountry(ipToAdd)) {
        if(ipElement.onTor && !this.ipsStandard.includes(ipToAdd)) {
          this.ipsTor.push(ipToAdd);
        }else if(!ipElement.onTor && !this.ipsTor.includes(ipToAdd) ){
          this.ipsStandard.push(ipToAdd);
        }
      }
    }
  });
}

private ipsIncludeCountry(ipElement: Ip): boolean {
  let isCountryIncluded: boolean = false;
  this.ipsStandard.forEach(ip => {
    if(ip.country === ipElement.country) {
      isCountryIncluded = true;
    }
  });
  this.ipsTor.forEach(ip => {
    if(ip.country === ipElement.country) {
      isCountryIncluded = true;
    }
  });
  return isCountryIncluded;
}

private sortIpsWithTorFirst(ips: Ip[]): Ip[] {
  const compareIps = (ip1: Ip, ip2: Ip): number => {
    if (ip1.onTor == ip2.onTor) {
      return 0;
    }
    if(ip1.onTor) {
      return -1;
    }
    return 1;
  }
  const ipsWithTorFirst: Ip[] = this.cloneIps(ips); 
  return ipsWithTorFirst.sort(compareIps);
}

  private cloneIps(ips: Ip[]): Ip[] {
    const clonedIps: Ip[] = [];
    ips.forEach(ip => {
      clonedIps.push(ip);
    });
    return clonedIps;
  }
}
